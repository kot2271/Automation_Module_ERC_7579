// SPDX-License-Identifier: MIT
pragma solidity ^0.8.25;

import {LibClone} from "node_modules/solady/src/utils/LibClone.sol";
import {IMSA} from "node_modules/erc7579/src/interfaces/IMSA.sol";
import "@openzeppelin/contracts/proxy/Clones.sol";

/**
 * @title SCAFactory contract is a factory that creates instances of the SCA contract
 */
contract SCAFactory {
    // The address of the SCA implementation contract
    address public immutable implementation;

    /**
     * @dev The address of the entrypoint for the SCA implementation contract.
     * This is the address of the contract that the SCA instances will call
     * when executing workflows.
     */
    address public immutable entrypoint;

    // Event emitted when a new SCA instance is created
    event CloneCreated(address indexed implementation, address clone);

    // Error thrown when the initialize function fails
    error InitializeError();

    /**
     * @dev Constructor for the SCAFactory contract
     * @param _scaImplementation The address of the SCA implementation contract
     */
    constructor(address _scaImplementation, address _entrypoint) {
        implementation = _scaImplementation;
        entrypoint = _entrypoint;
    }

    /**
     * @dev Fallback function to receive Ether
     */
    receive() external payable {}

    /**
     * @dev Fallback function without parameters
     */
    fallback() external {}

    /**
     * @dev Returns the address of a new SCA instance
     * @param salt The salt used to generate the address
     * @param initcode The initialization code for the SCA instance
     * @return The address of the SCA instance
     */
    function getAddress(
        bytes32 salt,
        bytes calldata initcode
    ) public view virtual returns (address) {
        bytes32 _salt = _getSalt(salt, initcode);
        return
            LibClone.predictDeterministicAddressERC1967(
                implementation,
                _salt,
                address(this)
            );
    }

    /**
     * @dev Returns the salt generated from a given salt and initialization code
     * @param _salt The original salt
     * @param initCode The initialization code
     * return The generated bytes32 salt
     */
    function _getSalt(
        bytes32 _salt,
        bytes calldata initCode
    ) public pure virtual returns (bytes32 salt) {
        salt = keccak256(abi.encodePacked(_salt, initCode));
    }

    /**
     * @dev Creates a new SCA instance
     * @param salt The salt used to generate the address
     * @param initCode The initialization code for the SCA instance
     * @return The address of the SCA instance
     */
    function createAccount(
        bytes32 salt,
        bytes calldata initCode
    ) public payable virtual returns (address) {
        bytes32 _salt = _getSalt(salt, initCode);
        (bool alreadyDeployed, address account) = LibClone
            .createDeterministicERC1967(msg.value, implementation, _salt);

        if (!alreadyDeployed) {
            account = _deployImplementation(implementation, address(this));
        }
        return account;
    }

    /**
     * @dev Deploys a new instance of the SCA implementation contract
     * @param implementationContract The address of the SCA implementation contract
     * @param _owner The address of the owner of the SCA instance
     * @return The address of the deployed SCA instance
     */
    function _deployImplementation(
        address implementationContract,
        address _owner
    ) internal returns (address) {
        // Clone the implementation contract
        address clone = Clones.clone(implementationContract);
        // call the encoded initializer function call on the clone
        (bool initSuccess, ) = clone.call(
            abi.encodeWithSignature(
                "initialize(address,address)",
                entrypoint,
                _owner
            )
        );
        if (!initSuccess) {
            revert InitializeError();
        }

        // Emit the CloneCreated event
        emit CloneCreated(implementationContract, clone);
        return clone;
    }
}
